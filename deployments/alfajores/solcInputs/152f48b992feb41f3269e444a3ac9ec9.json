{
  "language": "Solidity",
  "sources": {
    "contracts/common/MultiSig.sol": {
      "content": "//SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/ExternalCall.sol\";\n\n/**\n * @title Multisignature wallet - Allows multiple parties to agree on proposals before\n * execution.\n * @author Stefan George - <stefan.george@consensys.net>\n * @dev NOTE: This contract has its limitations and is not viable for every\n * multi-signature setup. On a case by case basis, evaluate whether this is the\n * correct contract for your use case.\n * In particular, this contract doesn't have an atomic \"add owners and increase\n * requirement\" operation.\n * This can be tricky, for example, in a situation where a MultiSig starts out\n * owned by a single owner. Safely increasing the owner set and requirement at\n * the same time is not trivial. One way to work around this situation is to\n * first add a second address controlled by the original owner, increase the\n * requirement, and then replace the auxillary address with the intended second\n * owner.\n * Again, this is just one example, in general make sure to verify this contract\n * will support your intended usage. The goal of this contract is to offer a\n * simple, minimal multi-signature API that's easy to understand even for novice\n * Solidity users.\n * Forked from\n * github.com/celo-org/celo-monorepo/blob/master/packages/protocol/contracts/common/MultiSig.sol\n */\ncontract MultiSig is Initializable, UUPSUpgradeable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /**\n     * @notice The maximum number of multisig owners.\n     */\n    uint256 public constant MAX_OWNER_COUNT = 50;\n\n    /**\n     * @notice The minimum time in seconds that must elapse before a proposal is executable.\n     */\n    uint256 public immutable minDelay;\n\n    /**\n     * @notice The value used to mark a proposal as executed.\n     */\n    uint256 internal constant DONE_TIMESTAMP = uint256(1);\n\n    /**\n     * @notice Used to keep track of a proposal.\n     * @param destinations The addresses at which the proposal is directed to.\n     * @param values The amounts of CELO involved.\n     * @param payloads The payloads of the proposal.\n     * @param timestampExecutable The timestamp at which a proposal becomes executable.\n     * @dev timestampExecutable is 0 if proposal is not yet scheduled or 1 if the proposal\n     * is executed.\n     * @param confirmations The list of confirmations. Keyed by the address that\n     * confirmed the proposal, whether or not the proposal is confirmed.\n     */\n    struct Proposal {\n        address[] destinations;\n        uint256[] values;\n        bytes[] payloads;\n        uint256 timestampExecutable;\n        mapping(address => bool) confirmations;\n    }\n\n    /**\n     * @notice The delay that must elapse to be able to execute a proposal.\n     */\n    uint256 public delay;\n\n    /**\n     * @notice Keyed by proposal ID, the Proposal record.\n     */\n    mapping(uint256 => Proposal) public proposals;\n\n    /**\n     * @notice The set of addresses which are owners of the multisig.\n     */\n    EnumerableSet.AddressSet private owners;\n\n    /**\n     * @notice The amount of confirmations required\n     * for a proposal to be fully confirmed.\n     */\n    uint256 public required;\n\n    /**\n     * @notice The total count of proposals.\n     */\n    uint256 public proposalCount;\n\n    /**\n     * @notice Used when a proposal is successfully confirmed.\n     * @param sender The address of the sender.\n     * @param proposalId The ID of the proposal.\n     */\n    event ProposalConfirmed(address indexed sender, uint256 indexed proposalId);\n\n    /**\n     * @notice Used when a confirmation is successfully revoked.\n     * @param sender The address of the sender.\n     * @param proposalId The ID of the proposal.\n     */\n    event ConfirmationRevoked(address indexed sender, uint256 indexed proposalId);\n\n    /**\n     * @notice Used when a proposal is successfully added.\n     * @param proposalId The ID of the proposal that was added.\n     */\n    event ProposalAdded(uint256 indexed proposalId);\n\n    /**\n     * @notice Emitted when a confirmed proposal is successfully executed.\n     * @param proposalId The ID of the proposal that was executed.\n     * @param returnData The response that was recieved from the external call.\n     */\n    event ProposalExecuted(uint256 indexed proposalId, bytes returnData);\n\n    /**\n     * @notice Emitted when one of the transactions that make up a proposal is successfully\n     * executed.\n     * @param index The index of the transaction within the proposal.\n     * @param proposalId The ID of the proposal.\n     * @param returnData The response that was recieved from the external call.\n     */\n    event TransactionExecuted(uint256 index, uint256 indexed proposalId, bytes returnData);\n\n    /**\n     * @notice Emitted when CELO is sent to this contract.\n     * @param sender The account which sent the CELO.\n     * @param value The amount of CELO sent.\n     */\n    event CeloDeposited(address indexed sender, uint256 value);\n\n    /**\n     * @notice Emitted when an Owner is successfully added as part of the multisig.\n     * @param owner The added owner.\n     */\n    event OwnerAdded(address indexed owner);\n\n    /**\n     * @notice Emitted when an Owner is successfully removed from the multisig.\n     * @param owner The removed owner.\n     */\n    event OwnerRemoved(address indexed owner);\n\n    /**\n     * @notice Emitted when the minimum amount of required confirmations is\n     * successfully changed.\n     * @param required The new required amount.\n     */\n    event RequirementChanged(uint256 required);\n\n    /**\n     * @notice Emitted when a proposal is scheduled.\n     * @param proposalId The ID of the proposal that is scheduled.\n     */\n    event ProposalScheduled(uint256 indexed proposalId);\n\n    /**\n     * @notice Used when `delay` is changed.\n     * @param delay The current delay value.\n     * @param newDelay The new delay value.\n     */\n    event DelayChanged(uint256 delay, uint256 newDelay);\n\n    /**\n     * @notice Used when sender is not this contract in an `onlyWallet` function.\n     * @param account The sender which triggered the function.\n     */\n    error SenderMustBeMultisigWallet(address account);\n\n    /**\n     * @notice Used when attempting to add an already existing owner.\n     * @param owner The address of the owner.\n     */\n    error OwnerAlreadyExists(address owner);\n\n    /**\n     * @notice Used when an owner does not exist.\n     * @param owner The address of the owner.\n     */\n    error OwnerDoesNotExist(address owner);\n\n    /**\n     * @notice Used when a proposal does not exist.\n     * @param proposalId The ID of the non-existent proposal.\n     */\n    error ProposalDoesNotExist(uint256 proposalId);\n\n    /**\n     * @notice Used when a proposal is not confirmed by a given owner.\n     * @param proposalId The ID of the proposal that is not confirmed.\n     * @param owner The address of the owner which did not confirm the proposal.\n     */\n    error ProposalNotConfirmed(uint256 proposalId, address owner);\n\n    /**\n     * @notice Used when a proposal is not fully confirmed.\n     * @dev A proposal is fully confirmed when the `required` threshold\n     * of confirmations has been met.\n     * @param proposalId The ID of the proposal that is not fully confirmed.\n     */\n    error ProposalNotFullyConfirmed(uint256 proposalId);\n\n    /**\n     * @notice Used when a proposal is already confirmed by an owner.\n     * @param proposalId The ID of the proposal that is already confirmed.\n     * @param owner The address of the owner which confirmed the proposal.\n     */\n    error ProposalAlreadyConfirmed(uint256 proposalId, address owner);\n\n    /**\n     * @notice Used when a proposal has been executed.\n     * @param proposalId The ID of the proposal that is already executed.\n     */\n    error ProposalAlreadyExecuted(uint256 proposalId);\n\n    /**\n     * @notice Used when a passed address is address(0).\n     */\n    error NullAddress();\n\n    /**\n     * @notice Used when the set threshold values for owner and minimum\n     * required confirmations are not met.\n     * @param ownerCount The count of owners.\n     * @param required The number of required confirmations.\n     */\n    error InvalidRequirement(uint256 ownerCount, uint256 required);\n\n    /**\n     * @notice Used when attempting to remove the last owner.\n     * @param owner The last owner.\n     */\n    error CannotRemoveLastOwner(address owner);\n\n    /**\n     * @notice Used when attempting to schedule an already scheduled proposal.\n     * @param proposalId The ID of the proposal which is already scheduled.\n     */\n    error ProposalAlreadyScheduled(uint256 proposalId);\n\n    /**\n     * @notice Used when a proposal is not scheduled.\n     * @param proposalId The ID of the proposal which is not scheduled.\n     */\n    error ProposalNotScheduled(uint256 proposalId);\n\n    /**\n     * @notice Used when a time lock delay is not reached.\n     * @param proposalId The ID of the proposal whose time lock has not been reached yet.\n     */\n    error ProposalTimelockNotReached(uint256 proposalId);\n\n    /**\n     * @notice Used when a provided value is less than the minimum time lock delay.\n     * @param delay The insufficient delay.\n     */\n    error InsufficientDelay(uint256 delay);\n\n    /**\n     * @notice Used when the sizes of the provided arrays params do not match\n     * when submitting a proposal.\n     */\n    error ParamLengthsMismatch();\n\n    /**\n     * @notice Checks that only the multisig contract can execute a function.\n     */\n    modifier onlyWallet() {\n        if (msg.sender != address(this)) {\n            revert SenderMustBeMultisigWallet(msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @notice Checks that an address is not a multisig owner.\n     * @param owner The address to check.\n     */\n    modifier ownerDoesNotExist(address owner) {\n        if (owners.contains(owner)) {\n            revert OwnerAlreadyExists(owner);\n        }\n        _;\n    }\n\n    /**\n     * @notice Checks that an address is a multisig owner.\n     * @param owner The address to check.\n     */\n    modifier ownerExists(address owner) {\n        if (!owners.contains(owner)) {\n            revert OwnerDoesNotExist(owner);\n        }\n        _;\n    }\n\n    /**\n     * @notice Checks that a proposal exists.\n     * @param proposalId The proposal ID to check.\n     */\n    modifier proposalExists(uint256 proposalId) {\n        if (proposals[proposalId].destinations.length == 0) {\n            revert ProposalDoesNotExist(proposalId);\n        }\n        _;\n    }\n\n    /**\n     * @notice Checks that a proposal has been confirmed by a multisig owner.\n     * @param proposalId The proposal ID to check.\n     * @param owner The owner to check.\n     */\n    modifier confirmed(uint256 proposalId, address owner) {\n        if (!proposals[proposalId].confirmations[owner]) {\n            revert ProposalNotConfirmed(proposalId, owner);\n        }\n        _;\n    }\n\n    /**\n     * @notice Checks that a proposal has not been confirmed by a multisig owner.\n     * @param proposalId The proposal ID to check.\n     * @param owner The owner to check.\n     */\n    modifier notConfirmed(uint256 proposalId, address owner) {\n        if (proposals[proposalId].confirmations[owner]) {\n            revert ProposalAlreadyConfirmed(proposalId, owner);\n        }\n        _;\n    }\n\n    /**\n     * @notice Checks that a proposal has not been executed.\n     * @dev A proposal can only be executed after it is fully confirmed.\n     * @param proposalId The proposal ID to check.\n     */\n    modifier notExecuted(uint256 proposalId) {\n        if (proposals[proposalId].timestampExecutable == DONE_TIMESTAMP) {\n            revert ProposalAlreadyExecuted(proposalId);\n        }\n        _;\n    }\n\n    /**\n     * @notice Checks that an address is not address(0).\n     * @param addr The address to check.\n     */\n    modifier notNull(address addr) {\n        if (addr == address(0)) {\n            revert NullAddress();\n        }\n        _;\n    }\n\n    /**\n     * @notice Checks that each address in a batch of addresses are not address(0).\n     * @param _addresses The addresses to check.\n     */\n    modifier notNullBatch(address[] memory _addresses) {\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            if (_addresses[i] == address(0)) {\n                revert NullAddress();\n            }\n        }\n        _;\n    }\n\n    /**\n     * @notice Checks that the values passed for number of multisig owners and required\n     * confirmation are valid in comparison with the configured thresholds.\n     * @param ownerCount The owners count to check.\n     * @param requiredConfirmations The minimum number of confirmations required to consider\n     * a proposal as fully confirmed.\n     */\n    modifier validRequirement(uint256 ownerCount, uint256 requiredConfirmations) {\n        if (\n            ownerCount > MAX_OWNER_COUNT ||\n            requiredConfirmations > ownerCount ||\n            requiredConfirmations == 0 ||\n            ownerCount == 0\n        ) {\n            revert InvalidRequirement(ownerCount, requiredConfirmations);\n        }\n        _;\n    }\n\n    /**\n     * @notice Checks that a proposal is scheduled.\n     * @param proposalId The ID of the proposal to check.\n     */\n    modifier scheduled(uint256 proposalId) {\n        if (!isScheduled(proposalId)) {\n            revert ProposalNotScheduled(proposalId);\n        }\n        _;\n    }\n\n    /**\n     * @notice Checks that a proposal is not scheduled.\n     * @param proposalId The ID of the proposal to check.\n     */\n    modifier notScheduled(uint256 proposalId) {\n        if (isScheduled(proposalId)) {\n            revert ProposalAlreadyScheduled(proposalId);\n        }\n        _;\n    }\n\n    /**\n     * @notice Checks that a proposal's time lock has elapsed.\n     * @param proposalId The ID of the proposal to check.\n     */\n    modifier timeLockReached(uint256 proposalId) {\n        if (!isProposalTimelockReached(proposalId)) {\n            revert ProposalTimelockNotReached(proposalId);\n        }\n        _;\n    }\n\n    /**\n     * @notice Checks that a proposal is fully confirmed.\n     * @param proposalId The ID of the proposal to check.\n     */\n    modifier fullyConfirmed(uint256 proposalId) {\n        if (!isFullyConfirmed(proposalId)) {\n            revert ProposalNotFullyConfirmed(proposalId);\n        }\n        _;\n    }\n\n    /**\n     * @notice Sets `initialized` to  true on implementation contracts.\n     * @param _minDelay The minimum time in seconds that must elapse before a\n     * proposal is executable.\n     */\n    // solhint-disable-next-line no-empty-blocks\n    constructor(uint256 _minDelay) initializer {\n        minDelay = _minDelay;\n    }\n\n    receive() external payable {\n        if (msg.value > 0) {\n            emit CeloDeposited(msg.sender, msg.value);\n        }\n    }\n\n    /**\n     * @notice Bootstraps this contract with initial data.\n     * @dev This plays the role of a typical contract constructor. Sets initial owners and\n     * required number of confirmations. The initializer modifier ensures that this function\n     * is ONLY callable once.\n     * @param initialOwners The list of initial owners.\n     * @param requiredConfirmations The number of required confirmations for a proposal\n     * to be fully confirmed.\n     * @param _delay The delay that must elapse to be able to execute a proposal.\n     */\n    function initialize(\n        address[] calldata initialOwners,\n        uint256 requiredConfirmations,\n        uint256 _delay\n    ) external initializer validRequirement(initialOwners.length, requiredConfirmations) {\n        for (uint256 i = 0; i < initialOwners.length; i++) {\n            if (owners.contains(initialOwners[i])) {\n                revert OwnerAlreadyExists(initialOwners[i]);\n            }\n\n            if (initialOwners[i] == address(0)) {\n                revert NullAddress();\n            }\n\n            owners.add(initialOwners[i]);\n            emit OwnerAdded(initialOwners[i]);\n        }\n        _changeRequirement(requiredConfirmations);\n        _changeDelay(_delay);\n    }\n\n    /**\n     * @notice Adds a new multisig owner.\n     * @dev This call can only be made by this contract.\n     * @param owner The owner to add.\n     */\n    function addOwner(address owner)\n        external\n        onlyWallet\n        ownerDoesNotExist(owner)\n        notNull(owner)\n        validRequirement(owners.length() + 1, required)\n    {\n        owners.add(owner);\n        emit OwnerAdded(owner);\n    }\n\n    /**\n     * @notice Removes an existing owner.\n     * @dev This call can only be made by this contract.\n     * @param owner The owner to remove.\n     */\n    function removeOwner(address owner) external onlyWallet ownerExists(owner) {\n        if (owners.length() == 1) {\n            revert CannotRemoveLastOwner(owner);\n        }\n\n        owners.remove(owner);\n\n        if (required > owners.length()) {\n            // Readjust the required amount, since the list of total owners has reduced.\n            changeRequirement(owners.length());\n        }\n        emit OwnerRemoved(owner);\n    }\n\n    /**\n     * @notice Replaces an existing owner with a new owner.\n     * @dev This call can only be made by this contract.\n     * @param owner The owner to be replaced.\n     */\n    function replaceOwner(address owner, address newOwner)\n        external\n        onlyWallet\n        ownerExists(owner)\n        notNull(newOwner)\n        ownerDoesNotExist(newOwner)\n    {\n        owners.remove(owner);\n        owners.add(newOwner);\n        emit OwnerRemoved(owner);\n        emit OwnerAdded(newOwner);\n    }\n\n    /**\n     * @notice Void a confirmation for a previously confirmed proposal.\n     * @param proposalId The ID of the proposal to be revoked.\n     */\n    function revokeConfirmation(uint256 proposalId)\n        external\n        ownerExists(msg.sender)\n        confirmed(proposalId, msg.sender)\n        notExecuted(proposalId)\n    {\n        proposals[proposalId].confirmations[msg.sender] = false;\n        emit ConfirmationRevoked(msg.sender, proposalId);\n    }\n\n    /**\n     * @notice Creates a proposal and triggers the first confirmation on behalf of the\n     * proposal creator.\n     * @param destinations The addresses at which the proposal is target at.\n     * @param values The CELO values involved in the proposal if any.\n     * @param payloads The payloads of the proposal.\n     * @return proposalId Returns the ID of the proposal that gets generated.\n     */\n    function submitProposal(\n        address[] calldata destinations,\n        uint256[] calldata values,\n        bytes[] calldata payloads\n    ) external returns (uint256 proposalId) {\n        if (destinations.length != values.length) {\n            revert ParamLengthsMismatch();\n        }\n\n        if (destinations.length != payloads.length) {\n            revert ParamLengthsMismatch();\n        }\n        proposalId = addProposal(destinations, values, payloads);\n        confirmProposal(proposalId);\n    }\n\n    /**\n     * @notice Get the list of multisig owners.\n     * @return The list of owner addresses.\n     */\n    function getOwners() external view returns (address[] memory) {\n        return owners.values();\n    }\n\n    /**\n     * @notice Gets the list of owners' addresses which have confirmed a given proposal.\n     * @param proposalId The ID of the proposal.\n     * @return The list of owner addresses.\n     */\n    function getConfirmations(uint256 proposalId) external view returns (address[] memory) {\n        address[] memory confirmationsTemp = new address[](owners.length());\n        uint256 count = 0;\n        for (uint256 i = 0; i < owners.length(); i++) {\n            if (proposals[proposalId].confirmations[owners.at(i)]) {\n                confirmationsTemp[count] = owners.at(i);\n                count++;\n            }\n        }\n        address[] memory confirmingOwners = new address[](count);\n        for (uint256 i = 0; i < count; i++) {\n            confirmingOwners[i] = confirmationsTemp[i];\n        }\n        return confirmingOwners;\n    }\n\n    /**\n     * @notice Gets the destinations, values and payloads of a proposal.\n     * @param proposalId The ID of the proposal.\n     * @param destinations The addresses at which the proposal is target at.\n     * @param values The CELO values involved in the proposal if any.\n     * @param payloads The payloads of the proposal.\n     */\n    function getProposal(uint256 proposalId)\n        external\n        view\n        returns (\n            address[] memory destinations,\n            uint256[] memory values,\n            bytes[] memory payloads\n        )\n    {\n        Proposal storage proposal = proposals[proposalId];\n        return (proposal.destinations, proposal.values, proposal.payloads);\n    }\n\n    /**\n     * @notice Changes the number of confirmations required to consider a proposal\n     * fully confirmed.\n     * @dev Proposal has to be sent by wallet.\n     * @param newRequired The new number of confirmations required.\n     */\n    function changeRequirement(uint256 newRequired)\n        public\n        onlyWallet\n        validRequirement(owners.length(), newRequired)\n    {\n        _changeRequirement(newRequired);\n    }\n\n    /**\n     * @notice Changes the value of the delay that must\n     * elapse before a proposal can become executable.\n     * @dev Proposal has to be sent by wallet.\n     * @param newDelay The new delay value.\n     */\n    function changeDelay(uint256 newDelay) public onlyWallet {\n        _changeDelay(newDelay);\n    }\n\n    /**\n     * @notice Confirms a proposal. A proposal is executed if this confirmation\n     * makes it fully confirmed.\n     * @param proposalId The ID of the proposal to confirm.\n     */\n    function confirmProposal(uint256 proposalId)\n        public\n        ownerExists(msg.sender)\n        proposalExists(proposalId)\n        notConfirmed(proposalId, msg.sender)\n    {\n        proposals[proposalId].confirmations[msg.sender] = true;\n        emit ProposalConfirmed(msg.sender, proposalId);\n        if (isFullyConfirmed(proposalId)) {\n            scheduleProposal(proposalId);\n        }\n    }\n\n    /**\n     * @notice Schedules a proposal with a time lock.\n     * @param proposalId The ID of the proposal to confirm.\n     */\n    function scheduleProposal(uint256 proposalId)\n        public\n        ownerExists(msg.sender)\n        notExecuted(proposalId)\n    {\n        schedule(proposalId);\n        emit ProposalScheduled(proposalId);\n    }\n\n    /**\n     * @notice Executes a proposal. A proposal is only executetable if it is fully confirmed,\n     * scheduled and the set delay has elapsed.\n     * @dev Any of the multisig owners can execute a given proposal, even though they may\n     * not have participated in its confirmation process.\n     */\n    function executeProposal(uint256 proposalId)\n        public\n        scheduled(proposalId)\n        notExecuted(proposalId)\n        timeLockReached(proposalId)\n    {\n        Proposal storage proposal = proposals[proposalId];\n        proposal.timestampExecutable = DONE_TIMESTAMP;\n\n        for (uint256 i = 0; i < proposals[proposalId].destinations.length; i++) {\n            bytes memory returnData = ExternalCall.execute(\n                proposal.destinations[i],\n                proposal.values[i],\n                proposal.payloads[i]\n            );\n            emit TransactionExecuted(i, proposalId, returnData);\n        }\n    }\n\n    /**\n     * @notice Returns the timestamp at which a proposal becomes executable.\n     * @param proposalId The ID of the proposal.\n     * @return The timestamp at which the proposal becomes executable.\n     */\n    function getTimestamp(uint256 proposalId) public view returns (uint256) {\n        return proposals[proposalId].timestampExecutable;\n    }\n\n    /**\n     * @notice Returns whether a proposal is scheduled.\n     * @param proposalId The ID of the proposal to check.\n     * @return Whether or not the proposal is scheduled.\n     */\n    function isScheduled(uint256 proposalId) public view returns (bool) {\n        return getTimestamp(proposalId) > DONE_TIMESTAMP;\n    }\n\n    /**\n     * @notice Returns whether a proposal is executable or not.\n     * A proposal is executable if it is scheduled, the delay has elapsed\n     * and it is not yet executed.\n     * @param proposalId The ID of the proposal to check.\n     * @return Whether or not the time lock is reached.\n     */\n    function isProposalTimelockReached(uint256 proposalId) public view returns (bool) {\n        uint256 timestamp = getTimestamp(proposalId);\n        return\n            timestamp <= block.timestamp &&\n            proposals[proposalId].timestampExecutable > DONE_TIMESTAMP;\n    }\n\n    /**\n     * @notice Checks that a proposal has been confirmed by at least the `required`\n     * number of owners.\n     * @param proposalId The ID of the proposal to check.\n     * @return Whether or not the proposal is confirmed by the minimum set of owners.\n     */\n    function isFullyConfirmed(uint256 proposalId) public view returns (bool) {\n        uint256 count = 0;\n        for (uint256 i = 0; i < owners.length(); i++) {\n            if (proposals[proposalId].confirmations[owners.at(i)]) {\n                count++;\n            }\n            if (count == required) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Checks that a proposal is confirmed by an owner.\n     * @param proposalId The ID of the proposal to check.\n     * @param owner The address to check.\n     * @return Whether or not the proposal is confirmed by the given owner.\n     */\n    function isConfirmedBy(uint256 proposalId, address owner) public view returns (bool) {\n        return proposals[proposalId].confirmations[owner];\n    }\n\n    /**\n     * @notice Checks that an address is a multisig owner.\n     * @param owner The address to check.\n     * @return Whether or not the address is a multisig owner.\n     */\n    function isOwner(address owner) public view returns (bool) {\n        return owners.contains(owner);\n    }\n\n    /**\n     * @notice Adds a new proposal to the proposals list.\n     * @param destinations The addresses at which the proposal is directed to.\n     * @param values The CELO valuse involved in the proposal if any.\n     * @param payloads The payloads of the proposal.\n     * @return proposalId Returns the ID of the proposal that gets generated.\n     */\n    function addProposal(\n        address[] memory destinations,\n        uint256[] memory values,\n        bytes[] memory payloads\n    ) internal notNullBatch(destinations) returns (uint256 proposalId) {\n        proposalId = proposalCount;\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.destinations = destinations;\n        proposal.values = values;\n        proposal.payloads = payloads;\n\n        proposalCount++;\n        emit ProposalAdded(proposalId);\n    }\n\n    /**\n     * @notice Schedules a proposal with a time lock.\n     * @param proposalId The ID of the proposal to schedule.\n     */\n    function schedule(uint256 proposalId)\n        internal\n        notScheduled(proposalId)\n        fullyConfirmed(proposalId)\n    {\n        proposals[proposalId].timestampExecutable = block.timestamp + delay;\n    }\n\n    /**\n     * @notice Changes the value of the delay that must\n     * elapse before a proposal can become executable.\n     * @param newDelay The new delay value.\n     */\n    function _changeDelay(uint256 newDelay) internal {\n        if (newDelay < minDelay) {\n            revert InsufficientDelay(newDelay);\n        }\n\n        delay = newDelay;\n        emit DelayChanged(delay, newDelay);\n    }\n\n    /**\n     * @notice Changes the number of confirmations required to consider a proposal\n     * fully confirmed.\n     * @dev This method does not do any validation, see `changeRequirement`\n     * for how it is used with the requirement validation modifier.\n     * @param newRequired The new number of confirmations required.\n     */\n    function _changeRequirement(uint256 newRequired) internal {\n        required = newRequired;\n        emit RequirementChanged(newRequired);\n    }\n\n    /**\n     * @notice Guard method for UUPS (Universal Upgradable Proxy Standard)\n     * See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#transparent-vs-uups\n     * @dev This methods overrides the virtual one in UUPSUpgradeable and\n     * adds the onlyWallet modifer.\n     */\n    // solhint-disable-next-line no-empty-blocks\n    function _authorizeUpgrade(address) internal override onlyWallet {}\n\n    /**\n     * @notice Returns the storage, major, minor, and patch version of the contract.\n     * @return Storage version of the contract.\n     * @return Major version of the contract.\n     * @return Minor version of the contract.\n     * @return Patch version of the contract.\n     */\n    function getVersionNumber()\n        external\n        pure\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (1, 1, 1, 0);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is ERC1967Upgrade {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
    },
    "contracts/libraries/ExternalCall.sol": {
      "content": "//SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nlibrary ExternalCall {\n    /**\n     * @notice Used when destination is not a contract.\n     * @param destination The invalid destination address.\n     */\n    error InvalidContractAddress(address destination);\n\n    /**\n     * @notice Used when an execution fails.\n     */\n    error ExecutionFailed();\n\n    /**\n     * @notice Executes external call.\n     * @param destination The address to call.\n     * @param value The CELO value to be sent.\n     * @param data The data to be sent.\n     * @return The call return value.\n     */\n    function execute(\n        address destination,\n        uint256 value,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        if (data.length > 0) {\n            if (!Address.isContract(destination)) {\n                revert InvalidContractAddress(destination);\n            }\n        }\n\n        bool success;\n        bytes memory returnData;\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, returnData) = destination.call{value: value}(data);\n        if (!success) {\n            revert ExecutionFailed();\n        }\n\n        return returnData;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}